1. 如果有多个match的routes, 那么每个route都会被执行,直到遇到res.send(), 后面的route停止执行.

2. 中间件按顺序执行, 所以他们的顺序很重要.

3. next() - If the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging. - http://expressjs.com/en/guide/using-middleware.html

4. bower作为一个js依赖管理的工具，提供一种理想包管理方式，借助了npm的一些思想，为我们提供一个舒服的开发环境。 - http://blog.fens.me/nodejs-bower-intro/

5. 流模型: - https://github.com/substack/stream-handbook （English Edition）
			https://github.com/jabez128/stream-handbook  (Chinese Edition)

	var http = require('http');
	var fs = require('fs');

	var server = http.createServer(function (req, res) {
		var stream = fs.createReadStream(__dirname + '/data.txt');
		stream.pipe(res);
	});
	server.listen(8000);

	在这里，.pipe()方法会自动帮助我们监听data和end事件。上面的这段代码不仅简洁，
	而且data.txt文件中每一小段数据都将源源不断的发送到客户端。
	
6. gulp的书写模型 - https://www.npmjs.com/package/gulp
				  http://www.w3ctech.com/topic/134
				  http://www.tuicool.com/articles/AzI3Ib
	gulp.task('js', function () {
	  return gulp.src('js/*.js')
		.pipe(jshint())
		.pipe(jshint.reporter('default'))
		.pipe(uglify())
		.pipe(concat('app.js'))
		.pipe(gulp.dest('build'));
	});
	
7. 关于callback(result)回调函数:
	比如定义了如下函数, 最终把得到的result返回给该函数的callback后续执行函数:
		var insertDocument = function (db, bks, callback) {
			// hangle things
			callback(result);
		}
	那么在调用方调用该函数的时候, 需要定义这么一个callback后续执行函数function (result):
		insertDocument(db, books, function (result) {
			// do sth.
		})
	注意如果在定义函数的时候callback()只有一个参数, 如callback(result), 那么在定义function ()时, 
	也只定义一个参数, 若果定义为多个参数, 如callback(err, result), 那么返回的result将被放进err中, 
	而result得不到这个值(undefined) 
	
8. passport的HTTP request操作

	注意上面的代码里有个req.logIn()，它不是http模块原生的方法，也不是express中的方法，
	而是passport加上的，passport扩展了HTTP request，添加了四种方法。

	a. logIn(user, options, callback)：用login()也可以。
	作用是为登录用户初始化session。options可设置session为false，即不初始化session，默认为true。
	
	b. logOut()：别名为logout()。作用是登出用户，删除该用户session。不带参数。
		
	c. isAuthenticated()：不带参数。作用是测试该用户是否存在于session中（即是否已登录）。
	若存在返回true。事实上这个比登录验证要用的更多，毕竟session通常会保留一段时间，
	在此期间判断用户是否已登录用这个方法就行了。
	
	d. isUnauthenticated()：不带参数。和上面的作用相反。
	
9. passport(sessions()); 
	It simply authenticates the session (which is populated by express.session()). 
	It is equivalent to: passport.authenticate('session');
	Its run on every request. The session ID that is generated by Express, is 
	a unique ID which is roughly equivalent to an authentication token that 
	the browser sends with every request. The data stored in this session is used 
	to restore the authentication state of the user.
	
10. 如果是module.exports = function () {...}, 那么在require的时候, 
	一定要 require('...')(). 后面的括号一定不能省略.
	
11. passport.use('local', new LocalStrategy({
		usernameField: 'uname',
		passwordField: 'pword'
	},function (username, password, done) {});
	
	这里的uname和pword是form表单里面的input name, 回调函数里面username和password是表单里面的值.
	
12 (个人理解). 关于passport.authenticate()的位置. 它应该先认证, 再传到function (req, res) {}中, 如下:

	app.post('/login',
		passport.authenticate('local', {
			failureRedirect: '/login'
		}),
		function (req, res) {
			res.redirect('/');
	});
	
	以下是错误的方法 (把passport.authenticate()写在了 function (req, res) {}里面, 导致阻塞):

	authRouter.route('/login')
		.post(function (req, res) {
		passport.authenticate('local', function (err, user, info) {
			res.send(user);
		});
	});
	
13. 做passport.authenticate 认证的时候, 千万不能把回调函数写进passport.authenticate()里面... 
	(耽误了我一大晚上加一个早上!!)
	authRouter.route('/login')
		.post(passport.authenticate('local'), function (req, res) {
			console.log('here3');
			console.log(req.user);
			res.redirect('/auth/profile');
		});
	
14 (个人理解). 在从mongodb中读出数据的时候, 定义collection的时候, 后面要是存在的collection名 (近似理解为表名),
	否则读不出数据. 如下, users是已知存在的collection名.
	var collection = db.collection('users');
	
	
15 (个人理解). 关于:
	passport.serializeUser(function (user, callback) {})
	passport.deserializeUser(function (id, callback) {})	
	developers自己提供函数, passport自己获得user和user.id (这个是纯字符串ID, 
	要用ObejctID才能将它对象化,用以查询, 见point16), 并放进提供的function里面去用于执行.
	
16. 用ID查找记录的时候, 一定记得要用ObjectID来将ID对象化. 如下:
	collection.find({_id:new ObjectId(id)}).toArray(function());	
	
17. passport local stragety 运行流程:
	a. 程序挂起, passport和localStrategy会被挂起, 相应地部分会被执行.
	b. 提交表单, 根据router, 程序执行 passport.authenticate().
	c. passport找到localstrategy, 执行strategy里面的内容.执行完, 返回callback(null, user).
	d. 程序执行passport.serializeUser. passport会把user提供给该函数, 需要developer提供的函数返回ID.
	e. 程序认证完成, 执行passport.authenticate('local', function(){})里面的回调函数function(){}.
	f. 执行完之后, 如果其中或者以后有跳转, 如res.redirect('/auth/profile'), 那么程序
	   将执行passport.deserializeUser(function (id, callback) {}).其中passport会提供user._id.
	g. 执行完毕之后, 程序返回到跳转目的地 "/auth/profile", req中仍然包含user.
	h. 以后每一次request, 都会执行反序列化passport.deserializeUser().
	
18(个人理解). callback(param1, param2); 
	第一个一般表示错误err, 如果非空, 则表示有错误.	这个可以填err, 或者是自己的报错信息加err.
	第二个一般是个需要返回的对象, 比如user. 如果失败, 则写false
	
19. JavaScript对于函数的定义和使用方法. 还有module.exports与require中传参的过程.	
	a. JS的两种通常的定义函数的方式:
		1. function box(a, b) { return a+b;}
		2. var box = function (a, b) (return a+b);
		这里box就是函数名.
	b. 关于require和module.exports. 以下面代码为例:
			calc.js:
				var add = function (a, b) {
					return a + b;
				}
				var minus = function (a, b) {
					return a - b;
				}
				module.exports = add;
			test.js:
				var calccc = require('./calc');
				console.log(typeof(calccc));
				console.log(calccc(1,2));
		这里exports出来的是一个函数, 因为=后面是一个函数. 在test.js里面require之后, calccc就是这个
		函数add, 在test.js中就可以用calccc(1，2). calccc的类型与add一样, calccc(1,2)得到的值的
		类型跟calc.js里面add函数return的值的类型也一样.
		
		这里有另外一个小技巧, 把函数包装到json里面返回:
			calc.js
				var add = function (a, b) {
					var add_two = function (c, d) {
						console.log((c+d)*a);
					}
					return {
						add_two: add_two
					};
				}
				var minus = function (a, b) {
					return a - b;
				}
				module.exports = add;
			test.js
				var calccc = require('./calc')(10,2);
				console.log(typeof(calccc.add_two));
				calccc.add_two(2,3);
		这想要在test.js里面用函数add_two, 还是比较困难的, 除非你把整个函数当成返回值返回. 那么在本例中,
		把函数包装到JSON对中返回(返回函数名即可), 在test.js中就可以访问了. 这里的calccc是返回值, 是个JSON, 
		是个object
		类型.那calccc.add_two, 并不是用点符号来去除内置函数, 而是通过JSON键值对取出的函数.

20. 注意, 调用完http.request()之后, 一定要用end()来表示request结束, 否则这个request会hanging.

21. 注意nodejs的异步性, 如果要等待一个程序执行完之后的结果,再来执行下一段代码, 那就用callback函数, 千万
	不能用return来回调. 举例:
	
	bookService.getBook(bookid, function (book) {
						console.log(book);
						console.log(typeof(book));
						res.render('bookView', {
							nav: nav,
							book: book
						});
					});
	本段函数是本人在这里犯过错的, 要等待book返回之后才能继续执行render, 如果只是在getBook里面return, 程序就
	不用关心book是否返回, 就直接执行render了.

























 2. 把request body加入序列化和反序列化中..新功能, 但是还不知道怎么用
 4 (个人理解). sessoin和cookie管理, 什么时候生成之类的. cookie随时都能发生, 比如curl http://127.0.0.1:8080 --cookie "Cho=Kim;Greet=Hello" , session也是, 比如在serializeUser的时候. 在这之前, cookie和session都开启.
 5. 密码加密 - bcrypt (安装bcrypt遇到问题)
	
	
	
	
	